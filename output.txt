----- activity_viz.py -----
import click
import sqlite3
from collections import defaultdict
from datetime import datetime, timedelta
from urllib.parse import urlparse
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich import box

MAX_GAP = 300  # Maximum gap in seconds (5 minutes) before considering it as inactivity

console = Console()

def get_db_connection():
    return sqlite3.connect('tracker.db')

def get_domain(url):
    try:
        return urlparse(url).netloc
    except:
        return "Unknown"

def process_activities(results):
    activity_summary = defaultdict(int)
    total_duration = 0
    last_timestamp = None
    last_activity = None
    gaps = []

    for row in results:
        timestamp, app_name, window_title, url = row[1:5]
        current_timestamp = datetime.strptime(timestamp, "%Y-%m-%d %H:%M:%S")
        
        activity = url if app_name in ['Brave Browser', 'Google Chrome', 'Safari', 'Firefox'] else app_name
        if activity.startswith('http'):
            activity = get_domain(activity)

        if last_timestamp and last_activity:
            duration = (current_timestamp - last_timestamp).total_seconds()
            if duration > MAX_GAP:
                gaps.append((last_timestamp, current_timestamp, duration))
            else:
                activity_summary[last_activity] += duration
                total_duration += duration

        last_timestamp = current_timestamp
        last_activity = activity

    return activity_summary, total_duration, gaps

def format_time(seconds):
    hours, remainder = divmod(int(seconds), 3600)
    minutes, seconds = divmod(remainder, 60)
    return f"{hours}h {minutes}m {seconds}s"

@click.group()
def cli():
    """Personal Activity Tracker CLI"""
    pass

@cli.command()
@click.option('--hours', type=int, help='Number of hours to summarize')
@click.option('--minutes', type=int, help='Number of minutes to summarize')
def summary(hours, minutes):
    """Provide a summary of activities for the last specified time period"""
    if hours is None and minutes is None:
        console.print("[bold red]Please specify either --hours or --minutes[/bold red]")
        return
    if hours is not None and minutes is not None:
        console.print("[bold red]Please specify either --hours or --minutes, not both[/bold red]")
        return
    
    if hours is not None:
        time_delta = timedelta(hours=hours)
        time_unit = "hour(s)"
        time_value = hours
    else:
        time_delta = timedelta(minutes=minutes)
        time_unit = "minute(s)"
        time_value = minutes

    conn = get_db_connection()
    cursor = conn.cursor()
    
    now = datetime.now()
    start_time = now - time_delta
    
    query = '''
    SELECT *
    FROM activities
    WHERE timestamp >= ? AND timestamp < ?
    ORDER BY timestamp
    '''
    
    cursor.execute(query, (start_time.strftime("%Y-%m-%d %H:%M:%S"), 
                           now.strftime("%Y-%m-%d %H:%M:%S")))
    results = cursor.fetchall()

    activity_summary, total_duration, gaps = process_activities(results)

    console.print(Panel(f"[bold cyan]Activity Summary for the last {time_value} {time_unit}[/bold cyan]", 
                        expand=False, border_style="cyan"))
    
    if results:
        console.print(f"[green]Data range:[/green] {results[0][1]} to {results[-1][1]}")
    
    requested_duration = time_delta.total_seconds()
    total_gap_time = requested_duration - total_duration
    
    table = Table(title="Time Summary", box=box.ROUNDED)
    table.add_column("Metric", style="cyan")
    table.add_column("Duration", style="magenta")
    table.add_row("Total tracked time", format_time(total_duration))
    table.add_row("Requested duration", str(time_delta))
    table.add_row("Total gap time", format_time(total_gap_time))
    console.print(table)
    
    coverage_percentage = (total_duration / requested_duration) * 100
    console.print(f"[bold green]Tracking coverage:[/bold green] {coverage_percentage:.2f}%") 
    
    console.print("\n[bold cyan]Top activities (% of tracked time):[/bold cyan]")
    activities_table = Table(box=box.SIMPLE)
    activities_table.add_column("Activity", style="cyan")
    activities_table.add_column("Duration", style="magenta")
    activities_table.add_column("Percentage", style="green")

    for activity, duration in sorted(activity_summary.items(), key=lambda x: x[1], reverse=True)[:10]:
        percentage = (duration / total_duration) * 100
        activities_table.add_row(
            activity, 
            format_time(duration),
            f"{percentage:.2f}%"
        )

    console.print(activities_table)

    conn.close()

if __name__ == '__main__':
    cli()\n\n
----- conversion_script.py -----
import sqlite3
from datetime import datetime
import pytz

def convert_timestamps():
    conn = sqlite3.connect('tracker.db')
    cursor = conn.cursor()

    # Define the local timezone
    local_tz = pytz.timezone('Asia/Singapore')

    # Fetch all records
    cursor.execute('SELECT id, timestamp FROM activities')
    records = cursor.fetchall()

    for record in records:
        record_id, utc_timestamp = record
        
        # Convert the UTC timestamp to a datetime object
        utc_dt = datetime.strptime(utc_timestamp, '%Y-%m-%d %H:%M:%S')
        
        # Set the timezone to UTC and then convert to local time
        utc_dt = pytz.utc.localize(utc_dt)
        local_dt = utc_dt.astimezone(local_tz)
        local_time = local_dt.strftime('%Y-%m-%d %H:%M:%S')

        # Update the record with the local time
        cursor.execute('UPDATE activities SET timestamp = ? WHERE id = ?', (local_time, record_id))

    conn.commit()
    conn.close()

if __name__ == "__main__":
    convert_timestamps()
\n\n
----- db_setup.py -----
import sqlite3

def create_database():
    conn = sqlite3.connect('tracker.db')
    cursor = conn.cursor()

    # Create the activities table
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS activities (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
        app_name TEXT NOT NULL,
        window_title TEXT,
        url TEXT
    )
    ''')

    conn.commit()
    conn.close()

    print("Database and table created successfully.")

if __name__ == "__main__":
    create_database()
\n\n
----- main.py -----
import time
import sqlite3
from AppKit import NSWorkspace
import subprocess

def run_applescript(script):
    try:
        result = subprocess.run(['osascript', '-e', script], capture_output=True, text=True, check=True)
        return result.stdout.strip()
    except subprocess.CalledProcessError:
        return None

def get_active_window_info():
    try:
        workspace = NSWorkspace.sharedWorkspace()
        active_app = workspace.activeApplication()
        app_name = active_app["NSApplicationName"]
        if app_name in ["Safari", "Google Chrome", "Firefox", "Brave Browser"]:
            script = f'''
            tell application "{app_name}"
                set currentTab to active tab of front window
                return (URL of currentTab) & "|" & (name of currentTab)
            end tell
            '''
            result = run_applescript(script)
            if result:
                url, title = result.split('|', 1)
                return app_name, title.strip(), url.strip()
        else:
            script = f'''
            tell application "System Events"
                tell process "{app_name}"
                    try
                        return name of front window
                    on error
                        return "No window title available"
                    end try
                end tell
            end tell
            '''
            window_title = run_applescript(script) or "No window title available"
            return app_name, window_title, None
    except Exception as e:
        print(f"Error getting window info: {e}")
        return None
    return None  # If we get here, something unexpected happened

def insert_activity(conn, timestamp, app_name, window_title, url):
    cursor = conn.cursor()
    cursor.execute('''
    INSERT INTO activities (timestamp, app_name, window_title, url)
    VALUES (?, ?, ?, ?)
    ''', (timestamp, app_name, window_title, url))
    conn.commit()
    print(f"inserted {timestamp}, {app_name}, {window_title}, {url}")

def main():
    conn = sqlite3.connect('tracker.db')
    
    last_app_name = None
    last_window_title = None
    last_url = None
    last_insert_time = None
    
    try:
        while True:
            current_time = time.strftime('%Y-%m-%d %H:%M:%S')
            window_info = get_active_window_info()
            
            if window_info is None:
                print("Failed to get window info. Retrying in 1 second...")
                time.sleep(1)
                continue
            
            app_name, window_title, url = window_info
            
            if (app_name != last_app_name or 
                window_title != last_window_title or 
                url != last_url or 
                (last_insert_time and (time.time() - last_insert_time) >= 1)):  # Force update every 5 minutes
                
                insert_activity(conn, current_time, app_name, window_title, url)
                
                last_app_name = app_name
                last_window_title = window_title
                last_url = url
                last_insert_time = time.time()
            
            time.sleep(1)  # Check every second
            
    except KeyboardInterrupt:
        print("\nTracking stopped.")
    finally:
        conn.close()

if __name__ == "__main__":
    main()\n\n
activity_viz.py
conversion_script.py
db_setup.py
main.py
output.txt
poetry.lock
print_all.fish
pyproject.toml
tracker.db
[tool.poetry]
name = "whatdid"
version = "0.1.0"
description = ""
authors = ["Your Name <you@example.com>"]
readme = "README.md"

[tool.poetry.dependencies]
python = "^3.12"
rich = "^13.7.1"
click = "^8.1.7"
plotext = "^5.2.8"
pytz = "^2024.1"


[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"
